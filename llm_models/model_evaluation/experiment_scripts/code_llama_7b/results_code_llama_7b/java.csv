id,name,explanation,code,Date
1,Selection Sort,The algorithm repeatedly selects the smallest  or largest  element from the unsorted portion of the list and swaps it with the first element of the unsorted part. This process is repeated for the remaining unsorted portion until the entire list is sorted.,"// Java program for implementation of Selection Sort
import http://java.io/.;
public class SelectionSort
{
void sort(int arr[])
{
int n = arr.length;
// One by one move boundary of unsorted subarray
for (int i = 0; i < n-1; i++)
{
// Find the minimum element in unsorted array
int min_idx = i;
for (int j = i+1; j < n; j++)
if (arr[j] < arr[min_idx])
min_idx = j;
// Swap the found minimum element with the first
// element
int temp = arr[min_idx];
arr[min_idx] = arr[i];
arr[i] = temp;
}
}
// Prints the array
void printArray(int arr[])
{
int n = arr.length;
for (int i=0; i<n; ++i)
System.out.print(arr[i]+"" "");
System.out.println();
}
// Driver code to test above
public static void main(String args[])
{
SelectionSort ob = new SelectionSort();
int arr[] = {64,25,12,22,11};
ob.sort(arr);
System.out.println(""Sorted array"");
ob.printArray(arr);
}
}
/ This code is contributed by Rajat Mishra*/",
2,Bubble Sort,Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst case time complexity is quite high.,"// Optimized java implementation of Bubble sort
import http://java.io/.*;
class GFG {
// An optimized version of Bubble Sort
static void bubbleSort(int arr[], int n)
{
int i, j, temp;
boolean swapped;
for (i = 0; i < n - 1; i++) {
swapped = false;
for (j = 0; j < n - i - 1; j++) {
if (arr[j] > arr[j + 1]) {
// Swap arr[j] and arr[j+1]
temp = arr[j];
arr[j] = arr[j + 1];
arr[j + 1] = temp;
swapped = true;
}
}
// If no two elements were
// swapped by inner loop, then break
if (swapped == false)
break;
}
}
// Function to print an array
static void printArray(int arr[], int size)
{
int i;
for (i = 0; i < size; i++)
System.out.print(arr[i] + "" "");
System.out.println();
}
// Driver program
public static void main(String args[])
{
int arr[] = { 64, 34, 25, 12, 22, 11, 90 };
int n = arr.length;
bubbleSort(arr, n);
System.out.println(""Sorted array: "");
printArray(arr, n);
}
}
// This code is contributed
// by Nikita Tiwari.",
3,Insertion Sort,"To sort an array of size N in ascending order iterate over the array and compare the current element  key  to its predecessor, if the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.","// Java program for implementation of Insertion Sort
public class InsertionSort {
/Function to sort array using insertion sort/
void sort(int arr[])
{
int n = arr.length;
for (int i = 1; i < n; ++i) {
int key = arr[i];
int j = i - 1;
/* Move elements of arr[0..i-1], that are
greater than key, to one position ahead
of their current position /
while (j >= 0 && arr[j] > key) {
arr[j + 1] = arr[j];
j = j - 1;
}
arr[j + 1] = key;
}
}
/ A utility function to print array of size n*/
static void printArray(int arr[])
{
int n = arr.length;
for (int i = 0; i < n; ++i)
System.out.print(arr[i] + "" "");
System.out.println();
}
// Driver method
public static void main(String args[])
{
int arr[] = { 12, 11, 13, 5, 6 };
InsertionSort ob = new InsertionSort();
ob.sort(arr);
printArray(arr);
}
};
/* This code is contributed by Rajat Mishra. */",
4,Merge Sort,"Merge sort is defined as a sorting algorithm that works by dividing an array into smaller subarrays, sorting each subarray, and then merging the sorted subarrays back together to form the final sorted array.","// Java program for Merge Sort
import http://java.io/.;
class MergeSort {
// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
void merge(int arr[], int l, int m, int r)
{
// Find sizes of two subarrays to be merged
int n1 = m - l + 1;
int n2 = r - m;
// Create temp arrays
int L[] = new int[n1];
int R[] = new int[n2];
// Copy data to temp arrays
for (int i = 0; i < n1; ++i)
L[i] = arr[l + i];
for (int j = 0; j < n2; ++j)
R[j] = arr[m + 1 + j];
// Merge the temp arrays
// Initial indices of first and second subarrays
int i = 0, j = 0;
// Initial index of merged subarray array
int k = l;
while (i < n1 && j < n2) {
if (L[i] <= R[j]) {
arr[k] = L[i];
i++;
}
else {
arr[k] = R[j];
j++;
}
k++;
}
// Copy remaining elements of L[] if any
while (i < n1) {
arr[k] = L[i];
i++;
k++;
}
// Copy remaining elements of R[] if any
while (j < n2) {
arr[k] = R[j];
j++;
k++;
}
}
// Main function that sorts arr[l..r] using
// merge()
void sort(int arr[], int l, int r)
{
if (l < r) {
// Find the middle point
int m = l + (r - l) / 2;
// Sort first and second halves
sort(arr, l, m);
sort(arr, m + 1, r);
// Merge the sorted halves
merge(arr, l, m, r);
}
}
// A utility function to print array of size n
static void printArray(int arr[])
{
int n = arr.length;
for (int i = 0; i < n; ++i)
System.out.print(arr[i] + "" "");
System.out.println();
}
// Driver code
public static void main(String args[])
{
int arr[] = { 12, 11, 13, 5, 6, 7 };
System.out.println(""Given array is"");
printArray(arr);
MergeSort ob = new MergeSort();
ob.sort(arr, 0, arr.length - 1);
System.out.println(""\nSorted array is"");
printArray(arr);
}
}
/ This code is contributed by Rajat Mishra */",
5,Quick Sort,QuickSort is a sorting algorithm based on the Divide and Conquer algorithm that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.,"// Java implementation of QuickSort
import http://java.io/.*;
class GFG {
// A utility function to swap two elements
static void swap(int[] arr, int i, int j)
{
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
}
// This function takes last element as pivot,
// places the pivot element at its correct position
// in sorted array, and places all smaller to left
// of pivot and all greater elements to right of pivot
static int partition(int[] arr, int low, int high)
{
// Choosing the pivot
int pivot = arr[high];
// Index of smaller element and indicates
// the right position of pivot found so far
int i = (low - 1);
for (int j = low; j <= high - 1; j++) {
// If current element is smaller than the pivot
if (arr[j] < pivot) {
// Increment index of smaller element
i++;
swap(arr, i, j);
}
}
swap(arr, i + 1, high);
return (i + 1);
}
// The main function that implements QuickSort
// arr[] --> Array to be sorted,
// low --> Starting index,
// high --> Ending index
static void quickSort(int[] arr, int low, int high)
{
if (low < high) {
// pi is partitioning index, arr[p]
// is now at right place
int pi = partition(arr, low, high);
// Separately sort elements before
// partition and after partition
quickSort(arr, low, pi - 1);
quickSort(arr, pi + 1, high);
}
}
// To print sorted array
public static void printArr(int[] arr)
{
for (int i = 0; i < arr.length; i++) {
System.out.print(arr[i] + "" "");
}
}
// Driver Code
public static void main(String[] args)
{
int[] arr = { 10, 7, 8, 9, 1, 5 };
int N = arr.length;
// Function call
quickSort(arr, 0, N - 1);
System.out.println(""Sorted array:"");
printArr(arr);
}
}
// This code is contributed by Ayush Choudhary
// Improved by Ajay Virmoti",
6,Heap Sort,Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements.,"// Java program for implementation of Heap Sort
public class HeapSort {
public void sort(int arr[])
{
int N = arr.length;
// Build heap (rearrange array)
for (int i = N / 2 - 1; i >= 0; i--)
heapify(arr, N, i);
// One by one extract an element from heap
for (int i = N - 1; i > 0; i--) {
// Move current root to end
int temp = arr[0];
arr[0] = arr[i];
arr[i] = temp;
// call max heapify on the reduced heap
heapify(arr, i, 0);
}
}
// To heapify a subtree rooted with node i which is
// an index in arr[]. n is size of heap
void heapify(int arr[], int N, int i)
{
int largest = i; // Initialize largest as root
int l = 2 * i + 1; // left = 2i + 1
int r = 2 * i + 2; // right = 2i + 2
// If left child is larger than root
if (l < N && arr[l] > arr[largest])
largest = l;
// If right child is larger than largest so far
if (r < N && arr[r] > arr[largest])
largest = r;
// If largest is not root
if (largest != i) {
int swap = arr[i];
arr[i] = arr[largest];
arr[largest] = swap;
// Recursively heapify the affected sub-tree
heapify(arr, N, largest);
}
}
/* A utility function to print array of size n */
static void printArray(int arr[])
{
int N = arr.length;
for (int i = 0; i < N; ++i)
System.out.print(arr[i] + "" "");
System.out.println();
}
// Driver's code
public static void main(String args[])
{
int arr[] = { 12, 11, 13, 5, 6, 7 };
int N = arr.length;
// Function call
HeapSort ob = new HeapSort();
ob.sort(arr);
System.out.println(""Sorted array is"");
printArray(arr);
}
}",
7,Radix Sort,Radix Sort is a linear sorting algorithm that sorts elements by processing them digit by digit. It is an efficient sorting algorithm for integers or strings with fixed size keys.,"// Radix sort Java implementation
import http://java.io/.;
import java.util.;
class Radix {
// A utility function to get maximum value in arr[]
static int getMax(int arr[], int n)
{
int mx = arr[0];
for (int i = 1; i < n; i++)
if (arr[i] > mx)
mx = arr[i];
return mx;
}
// A function to do counting sort of arr[] according to
// the digit represented by exp.
static void countSort(int arr[], int n, int exp)
{
int output[] = new int[n]; // output array
int i;
int count[] = new int[10];
Arrays.fill(count, 0);
// Store count of occurrences in count[]
for (i = 0; i < n; i++)
count[(arr[i] / exp) % 10]++;
// Change count[i] so that count[i] now contains
// actual position of this digit in output[]
for (i = 1; i < 10; i++)
count[i] += count[i - 1];
// Build the output array
for (i = n - 1; i >= 0; i--) {
output[count[(arr[i] / exp) % 10] - 1] = arr[i];
count[(arr[i] / exp) % 10]--;
}
// Copy the output array to arr[], so that arr[] now
// contains sorted numbers according to current
// digit
for (i = 0; i < n; i++)
arr[i] = output[i];
}
// The main function to that sorts arr[] of
// size n using Radix Sort
static void radixsort(int arr[], int n)
{
// Find the maximum number to know number of digits
int m = getMax(arr, n);
// Do counting sort for every digit. Note that
// instead of passing digit number, exp is passed.
// exp is 10^i where i is current digit number
for (int exp = 1; m / exp > 0; exp *= 10)
countSort(arr, n, exp);
}
// A utility function to print an array
static void print(int arr[], int n)
{
for (int i = 0; i < n; i++)
System.out.print(arr[i] + "" "");
}
// Main driver method
public static void main(String[] args)
{
int arr[] = { 170, 45, 75, 90, 802, 24, 2, 66 };
int n = arr.length;
// Function Call
radixsort(arr, n);
print(arr, n);
}
}",
8,Bucket Sort,"Bucket sort is a sorting technique that involves dividing elements into various groups, or buckets. These buckets are formed by uniformly distributing the elements. Once the elements are divided into buckets, they can be sorted using any other sorting algorithm. Finally, the sorted elements are gathered together in an ordered fashion.","// Java program to sort an array
// using bucket sort
import java.util.*;
import java.util.Collections;
class GFG {
// Function to sort arr[] of size n
// using bucket sort
static void bucketSort(float arr[], int n)
{
if (n <= 0)
return;
// 1) Create n empty buckets
@SuppressWarnings(""unchecked"")
Vector<Float>[] buckets = new Vector[n];
for (int i = 0; i < n; i++) {
buckets[i] = new Vector<Float>();
}
// 2) Put array elements in different buckets
for (int i = 0; i < n; i++) {
float idx = arr[i] * n;
buckets[(int)idx].add(arr[i]);
}
// 3) Sort individual buckets
for (int i = 0; i < n; i++) {
Collections.sort(buckets[i]);
}
// 4) Concatenate all buckets into arr[]
int index = 0;
for (int i = 0; i < n; i++) {
for (int j = 0; j < buckets[i].size(); j++) {
arr[index++] = buckets[i].get(j);
}
}
}
// Driver code
public static void main(String args[])
{
float arr[] = { (float)0.897, (float)0.565,
(float)0.656, (float)0.1234,
(float)0.665, (float)0.3434 };
int n = arr.length;
bucketSort(arr, n);
System.out.println(""Sorted array is "");
for (float el : arr) {
System.out.print(el + "" "");
}
}
}
// This code is contributed by Himangshu Shekhar Jha",
9,Bingo Sort,"This Sorting Technique is similar to the Selection Sort in which we first find the smallest element called Bingo Element, and then we repeatedly iterate the elements of the array to get the correct positions of all the elements. Similarly, find the next bingo element for the next pass, and so on. Every distinct element is considered a Bingo Element and called out in increasing order.","// Java Code for the above approach
import http://java.io/.*;
class GFG {
static int bingo;
static int nextBingo;
// Function for finding the maximum and minimum element
// of
// the Array
static void maxMin(int[] vec, int n)
{
for (int i = 1; i < n; i++) {
bingo = Math.min(bingo, vec[i]);
nextBingo = Math.max(nextBingo, vec[i]);
}
}
// Function to sort the array
static int[] bingoSort(int[] vec, int n)
{
bingo = vec[0];
nextBingo = vec[0];
maxMin(vec, n);
int largestEle = nextBingo;
int nextElePos = 0;
while (bingo < nextBingo) {
// Will keep the track of the element position
// to
// shifted to their correct position
int startPos = nextElePos;
for (int i = startPos; i < n; i++) {
if (vec[i] == bingo) {
int temp = vec[i];
vec[i] = vec[nextElePos];
vec[nextElePos] = temp;
nextElePos = nextElePos + 1;
}
// Here we are finding the next Bingo
// Element for the next pass
else if (vec[i] < nextBingo)
nextBingo = vec[i];
}
bingo = nextBingo;
nextBingo = largestEle;
}
return vec;
}
// Function to print the array
static void printArray(int[] arr, int n)
{
System.out.print(""Sorted Array: "");
for (int i = 0; i < n; i++) {
System.out.print(arr[i] + "" "");
}
System.out.println();
}
public static void main(String[] args)
{
int[] arr = { 5, 4, 8, 5, 4, 8, 5, 4, 4, 4 };
arr = bingoSort(arr, arr.length);
printArray(arr, arr.length);
int[] arr2 = { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
arr2 = bingoSort(arr2, arr2.length);
printArray(arr2, arr2.length);
int[] arr3 = { 0, 1, 0, 1, 0, 1 };
arr3 = bingoSort(arr3, arr3.length);
printArray(arr3, arr3.length);
}
}
// This code is contributed by lokeshmvs21.",
10,Shell Sort,"Shell sort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of ShellSort is to allow the exchange of far items. In Shell sort, we make the array h sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h sorted if all sublists of every h th element are sorted.","// Java implementation of ShellSort
class ShellSort
{
/* An utility function to print array of size n*/
static void printArray(int arr[])
{
int n = arr.length;
for (int i=0; i<n; ++i)
System.out.print(arr[i] + "" "");
System.out.println();
}
/* function to sort arr using shellSort */
int sort(int arr[])
{
int n = arr.length;
// Start with a big gap, then reduce the gap
for (int gap = n/2; gap > 0; gap /= 2)
{
// Do a gapped insertion sort for this gap size.
// The first gap elements a[0..gap-1] are already
// in gapped order keep adding one more element
// until the entire array is gap sorted
for (int i = gap; i < n; i += 1)
{
// add a[i] to the elements that have been gap
// sorted save a[i] in temp and make a hole at
// position i
int temp = arr[i];
// shift earlier gap-sorted elements up until
// the correct location for a[i] is found
int j;
for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)
arr[j] = arr[j - gap];
// put temp (the original a[i]) in its correct
// location
arr[j] = temp;
}
}
return 0;
}
// Driver method
public static void main(String args[])
{
int arr[] = {12, 34, 54, 2, 3};
System.out.println(""Array before sorting"");
printArray(arr);
ShellSort ob = new ShellSort();
ob.sort(arr);
System.out.println(""Array after sorting"");
printArray(arr);
}
}
/*This code is contributed by Rajat Mishra */",
11,Tim Sort,Tim Sort is a hybrid sorting algorithm derived from merge sort and insertion sort. It was designed to perform well on many kinds of real world data. Tim Sort is the default sorting algorithm used by Python s sorted   and list.sort   functions.,"// Java program to perform TimSort.
class GFG {
static int MIN_MERGE = 32;
public static int minRunLength(int n)
{
assert n >= 0;
// Becomes 1 if any 1 bits are shifted off
int r = 0;
while (n >= MIN_MERGE) {
r |= (n & 1);
n >>= 1;
}
return n + r;
}
// This function sorts array from left index to
// to right index which is of size atmost RUN
public static void insertionSort(int[] arr, int left,
int right)
{
for (int i = left + 1; i <= right; i++) {
int temp = arr[i];
int j = i - 1;
while (j >= left && arr[j] > temp) {
arr[j + 1] = arr[j];
j--;
}
arr[j + 1] = temp;
}
}
// Merge function merges the sorted runs
public static void merge(int[] arr, int l, int m, int r)
{
// Original array is broken in two parts
// left and right array
int len1 = m - l + 1, len2 = r - m;
int[] left = new int[len1];
int[] right = new int[len2];
for (int x = 0; x < len1; x++) {
left= arr[l + x];
}
for (int x = 0; x < len2; x++) {
right= arr[m + 1 + x];
}
int i = 0;
int j = 0;
int k = l;
// After comparing, we merge those two array
// in larger sub array
while (i < len1 && j < len2) {
if (left[i] <= right[j]) {
arr[k] = left[i];
i++;
}
else {
arr[k] = right[j];
j++;
}
k++;
}
// Copy remaining elements
// of left, if any
while (i < len1) {
arr[k] = left[i];
k++;
i++;
}
// Copy remaining element
// of right, if any
while (j < len2) {
arr[k] = right[j];
k++;
j++;
}
}
// Iterative Timsort function to sort the
// array[0...n-1] (similar to merge sort)
public static void timSort(int[] arr, int n)
{
int minRun = minRunLength(MIN_MERGE);
// Sort individual subarrays of size RUN
for (int i = 0; i < n; i += minRun) {
insertionSort(
arr, i,
Math.min((i + MIN_MERGE - 1), (n - 1)));
}
// Start merging from size
// RUN (or 32). It will
// merge to form size 64,
// then 128, 256 and so on
// ....
for (int size = minRun; size < n; size = 2 * size) {
// Pick starting point
// of left sub array. We
// are going to merge
// arr[left..left+size-1]
// and arr[left+size, left+2size-1]
// After every merge, we
// increase left by 2size
for (int left = 0; left < n; left += 2 * size) {
// Find ending point of left sub array
// mid+1 is starting point of right sub
// array
int mid = left + size - 1;
int right = Math.min((left + 2 * size - 1),
(n - 1));
// Merge sub array arr[left.....mid] &
// arr[mid+1....right]
if (mid < right)
merge(arr, left, mid, right);
}
}
}
// Utility function to print the Array
public static void printArray(int[] arr, int n)
{
for (int i = 0; i < n; i++) {
System.out.print(arr[i] + "" "");
}
System.out.print(""\n"");
}
// Driver code
public static void main(String[] args)
{
int[] arr = { -2, 7, 15, -14, 0, 15, 0, 7,
-7, -4, -13, 5, 8, -14, 12 };
int n = arr.length;
System.out.println(""Given Array is"");
printArray(arr, n);
timSort(arr, n);
System.out.println(""After Sorting Array is"");
printArray(arr, n);
}
}
// This code has been contributed by 29AjayKumar",
12,Comb Sort,Comb Sort is mainly an improvement over Bubble Sort. Bubble sort always compares adjacent values. So all inversions are removed one by one. Comb Sort improves on Bubble Sort by using a gap of the size of more than 1. The gap starts with a large value and shrinks by a factor of 1.3 in every iteration until it reaches the value 1. Thus Comb Sort removes more than one inversion count with one swap and performs better than Bubble Sort.,"// Java program for implementation of Comb Sort
import http://java.io/.;
public class CombSort
{
// To find gap between elements
int getNextGap(int gap)
{
// Shrink gap by Shrink factor
gap = (gap10)/13;
if (gap < 1)
return 1;
return gap;
}
// Function to sort arr[] using Comb Sort
void sort(int arr[])
{
int n = arr.length;
// initialize gap
int gap = n;
// Initialize swapped as true to make sure that
// loop runs
boolean swapped = true;
// Keep running while gap is more than 1 and last
// iteration caused a swap
while (gap != 1 || swapped == true)
{
// Find next gap
gap = getNextGap(gap);
// Initialize swapped as false so that we can
// check if swap happened or not
swapped = false;
// Compare all elements with current gap
for (int i=0; i<n-gap; i++)
{
if (arr[i] > arr[i+gap])
{
// Swap arr[i] and arr[i+gap]
int temp = arr[i];
arr[i] = arr[i+gap];
arr[i+gap] = temp;
// Set swapped
swapped = true;
}
}
}
}
// Driver method
public static void main(String args[])
{
CombSort ob = new CombSort();
int arr[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0};
ob.sort(arr);
System.out.println(""sorted array"");
for (int i=0; i<arr.length; ++i)
System.out.print(arr[i] + "" "");
}
}
/* This code is contributed by Rajat Mishra */",
13,Pigeonhole Sort,Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists of elements where the number of elements and the number of possible key values are approximately the same.,"/* Java program to implement Pigeonhole Sort /
import java.lang.;
import java.util.*;
public class GFG
{
public static void pigeonhole_sort(int arr[],
int n)
{
int min = arr[0];
int max = arr[0];
int range, i, j, index;
for(int a=0; a<n; a++)
{
if(arr[a] > max)
max = arr[a];
if(arr[a] < min)
min = arr[a];
}
range = max - min + 1;
int[] phole = new int[range];
Arrays.fill(phole, 0);
for(i = 0; i<n; i++)
phole[arr[i] - min]++;
index = 0;
for(j = 0; j<range; j++)
while(phole[j]-->0)
arr[index++]=j+min;
}
public static void main(String[] args)
{
GFG sort = new GFG();
int[] arr = {8, 3, 2, 7, 4, 6, 8};
System.out.print(""Sorted order is : "");
sort.pigeonhole_sort(arr,arr.length);
for(int i=0 ; i<arr.length ; i++)
System.out.print(arr[i] + "" "");
}
}
// Code contributed by Mohit Gupta_OMG <(0_o)>",
14,Cycle Sort,"The basic idea behind cycle sort is to divide the input array into cycles, where each cycle consists of elements that belong to the same position in the sorted output array. The algorithm then performs a series of swaps to place each element in its correct position within its cycle, until all cycles are complete and the array is sorted.","// Java program to implement cycle sort
import java.util.;
import java.lang.;
class GFG {
// Function sort the array using Cycle sort
public static void cycleSort(int arr[], int n)
{
// count number of memory writes
int writes = 0;
// traverse array elements and put it to on
// the right place
for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {
// initialize item as starting point
int item = arr[cycle_start];
// Find position where we put the item. We basically
// count all smaller elements on right side of item.
int pos = cycle_start;
for (int i = cycle_start + 1; i < n; i++)
if (arr[i] < item)
pos++;
// If item is already in correct position
if (pos == cycle_start)
continue;
// ignore all duplicate elements
while (item == arr[pos])
pos += 1;
// put the item to it's right position
if (pos != cycle_start) {
int temp = item;
item = arr[pos];
arr[pos] = temp;
writes++;
}
// Rotate rest of the cycle
while (pos != cycle_start) {
pos = cycle_start;
// Find position where we put the element
for (int i = cycle_start + 1; i < n; i++)
if (arr[i] < item)
pos += 1;
// ignore all duplicate elements
while (item == arr[pos])
pos += 1;
// put the item to it's right position
if (item != arr[pos]) {
int temp = item;
item = arr[pos];
arr[pos] = temp;
writes++;
}
}
}
}
// Driver program to test above function
public static void main(String[] args)
{
int arr[] = { 1, 8, 3, 9, 10, 10, 2, 4 };
int n = arr.length;
cycleSort(arr, n);
System.out.println(""After sort : "");
for (int i = 0; i < n; i++)
System.out.print(arr[i] + "" "");
}
}
// Code Contributed by Mohit Gupta_OMG <(0_o)>
",
15,Branch and Bound,Branch and bound is an algorithm design paradigm which is generally used for solving combinatorial optimization problems. These problems typically exponential in terms of time complexity and may require exploring all possible permutations in worst case. Branch and Bound solve these problems relatively quickly.,"import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;
class Item {
float weight;
int value;
Item(float weight, int value) {
this.weight = weight;
this.value = value;
}
}
class Node {
int level, profit, bound;
float weight;
Node(int level, int profit, float weight) {
this.level = level;
this.profit = profit;
this.weight = weight;
}
}
public class KnapsackBranchAndBound {
static Comparator<Item> itemComparator = (a, b) -> {
double ratio1 = (double) a.value / a.weight;
double ratio2 = (double) b.value / b.weight;
// Sorting in decreasing order of value per unit weight
return Double.compare(ratio2, ratio1);
};
static int bound(Node u, int n, int W, Item[] arr) {
if (u.weight >= W)
return 0;
int profitBound = u.profit;
int j = u.level + 1;
float totalWeight = u.weight;
while (j < n && totalWeight + arr[j].weight <= W) {
totalWeight += arr[j].weight;
profitBound += arr[j].value;
j++;
}
if (j < n)
profitBound += (int) ((W - totalWeight) * arr[j].value / arr[j].weight);
return profitBound;
}
static int knapsack(int W, Item[] arr, int n) {
Arrays.sort(arr, itemComparator);
PriorityQueue<Node> priorityQueue =
new PriorityQueue<>((a, b) -> Integer.compare(b.bound, a.bound));
Node u, v;
u = new Node(-1, 0, 0);
priorityQueue.offer(u);
int maxProfit = 0;
while (!priorityQueue.isEmpty()) {
u = priorityQueue.poll();
if (u.level == -1)
v = new Node(0, 0, 0);
else if (u.level == n - 1)
continue;
else
v = new Node(u.level + 1, u.profit, u.weight);
v.weight += arr[v.level].weight;
v.profit += arr[v.level].value;
if (v.weight <= W && v.profit > maxProfit)
maxProfit = v.profit;
v.bound = bound(v, n, W, arr);
if (v.bound > maxProfit)
priorityQueue.offer(v);
v = new Node(u.level + 1, u.profit, u.weight);
v.bound = bound(v, n, W, arr);
if (v.bound > maxProfit)
priorityQueue.offer(v);
}
return maxProfit;
}
public static void main(String[] args) {
int W = 10;
Item[] arr = {
new Item(2, 40),
new Item(3.14f, 50),
new Item(1.98f, 100),
new Item(5, 95),
new Item(3, 30)
};
int n = arr.length;
int maxProfit = knapsack(W, arr, n);
System.out.println(""Maximum possible profit = "" + maxProfit);
}
}",
16,Cocktail Sort,Cocktail Sort is a variation of Bubble sort. The Bubble sort algorithm always traverses elements from left and moves the largest element to its correct position in the first iteration and second largest in the second iteration and so on. Cocktail Sort traverses through a given array in both directions alternatively. Cocktail sort does not go through the unnecessary iteration making it efficient for large arrays.,"// Java program for implementation of Cocktail Sort
public class CocktailSort
{
void cocktailSort(int a[])
{
boolean swapped = true;
int start = 0;
int end = a.length;
while (swapped == true)
{
// reset the swapped flag on entering the
// loop, because it might be true from a
// previous iteration.
swapped = false;
// loop from bottom to top same as
// the bubble sort
for (int i = start; i < end - 1; ++i)
{
if (a[i] > a[i + 1]) {
int temp = a[i];
a[i] = a[i + 1];
a[i + 1] = temp;
swapped = true;
}
}
// if nothing moved, then array is sorted.
if (swapped == false)
break;
// otherwise, reset the swapped flag so that it
// can be used in the next stage
swapped = false;
// move the end point back by one, because
// item at the end is in its rightful spot
end = end - 1;
// from top to bottom, doing the
// same comparison as in the previous stage
for (int i = end - 1; i >= start; i--)
{
if (a[i] > a[i + 1])
{
int temp = a[i];
a[i] = a[i + 1];
a[i + 1] = temp;
swapped = true;
}
}
// increase the starting point, because
// the last stage would have moved the next
// smallest number to its rightful spot.
start = start + 1;
}
}
/* Prints the array */
void printArray(int a[])
{
int n = a.length;
for (int i = 0; i < n; i++)
System.out.print(a[i] + "" "");
System.out.println();
}
// Driver code
public static void main(String[] args)
{
CocktailSort ob = new CocktailSort();
int a[] = { 5, 1, 4, 2, 8, 0, 2 };
ob.cocktailSort(a);
System.out.println(""Sorted array"");
ob.printArray(a);
}
}
",
17,Strand Sort,Strand sort is a recursive sorting algorithm that sorts items of a list into increasing order. It has O n   worst time complexity which occurs when the input list is reverse sorted. It has a best case time complexity of O n  which occurs when the input is a list that is already sorted.,"// Java Code
import java.util.ArrayList;
import java.util.List;
public class StrandSort {
// Define a helper function to merge two sorted lists
public static List<Integer> mergeLists(List<Integer> list1, List<Integer> list2) {
List<Integer> result = new ArrayList<>();
while (!list1.isEmpty() && !list2.isEmpty()) {
if (list1.get(0) < list2.get(0)) {
result.add(list1.remove(0));
} else {
result.add(list2.remove(0));
}
}
result.addAll(list1);
result.addAll(list2);
return result;
}
// Recursive function to perform strand sort
public static List<Integer> strandSort(List<Integer> inputList) {
// Base case: if the input list has 1 or fewer elements, it's already sorted
if (inputList.size() <= 1) {
return inputList;
}
// Initialize a sublist with the first element of the input list
List<Integer> sublist = new ArrayList<>();
sublist.add(inputList.remove(0));
int i = 0;
while (i < inputList.size()) {
// If the current element in the input list is greater than
// the last element in the sublist,
// add it to the sublist; otherwise, continue to the next element in the input list.
if (inputList.get(i) > sublist.get(sublist.size() - 1)) {
sublist.add(inputList.remove(i));
} else {
i++;
}
}
// The sortedSublist contains the sorted elements from the current sublist
List<Integer> sortedSublist = new ArrayList<>(sublist);
// Recursively sort the remaining part of the input list
List<Integer> remainingList = strandSort(inputList);
// Merge the sorted sublist and the sorted remainingList
return mergeLists(sortedSublist, remainingList);
}
public static void main(String[] args) {
List<Integer> inputList = new ArrayList<>();
inputList.add(10);
inputList.add(5);
inputList.add(30);
inputList.add(40);
inputList.add(2);
inputList.add(4);
inputList.add(9);
List<Integer> outputList = strandSort(inputList);
for (int x : outputList) {
System.out.print(x + "" "");
}
}
}
// This code is contributed by guptapratik",
18,Bitonic Sort,"Bitonic Sort is a classic parallel algorithm for sorting.    The number of comparisons done by Bitonic sort is more than popular sorting algorithms like Merge Sort   does O log N  comparisons , but Bitonic sort is better for parallel implementation because we always compare elements in a predefined sequence and the sequence of comparison doesn t depend on data. Therefore it is suitable for implementation in hardware and parallel processor array.   Bitonic Sort can only be done if the number of elements to sort is 2 n. The procedure of bitonic sequence fails if the number of elements is not in the aforementioned quantity precisely.","/* Java program for Bitonic Sort. Note that this program
works only when size of input is a power of 2. /
public class BitonicSort
{
/ The parameter dir indicates the sorting direction,
ASCENDING or DESCENDING; if (a[i] > a[j]) agrees
with the direction, then a[i] and a[j] are
interchanged. /
void compAndSwap(int a[], int i, int j, int dir)
{
if ( (a[i] > a[j] && dir == 1) ||
(a[i] < a[j] && dir == 0))
{
// Swapping elements
int temp = a[i];
a[i] = a[j];
a[j] = temp;
}
}
/ It recursively sorts a bitonic sequence in ascending
order, if dir = 1, and in descending order otherwise
(means dir=0). The sequence to be sorted starts at
index position low, the parameter cnt is the number
of elements to be sorted./
void bitonicMerge(int a[], int low, int cnt, int dir)
{
if (cnt>1)
{
int k = cnt/2;
for (int i=low; i<low+k; i++)
compAndSwap(a,i, i+k, dir);
bitonicMerge(a,low, k, dir);
bitonicMerge(a,low+k, k, dir);
}
}
/ This function first produces a bitonic sequence by
recursively sorting its two halves in opposite sorting
orders, and then calls bitonicMerge to make them in
the same order */
void bitonicSort(int a[], int low, int cnt, int dir)
{
if (cnt>1)
{
int k = cnt/2;
// sort in ascending order since dir here is 1
bitonicSort(a, low, k, 1);
// sort in descending order since dir here is 0
bitonicSort(a,low+k, k, 0);
// Will merge whole sequence in ascending order
// since dir=1.
bitonicMerge(a, low, cnt, dir);
}
}
/*Caller of bitonicSort for sorting the entire array
of length N in ASCENDING order /
void sort(int a[], int N, int up)
{
bitonicSort(a, 0, N, up);
}
/ A utility function to print array of size n */
static void printArray(int arr[])
{
int n = arr.length;
for (int i=0; i<n; ++i)
System.out.print(arr[i] + "" "");
System.out.println();
}
// Driver method
public static void main(String args[])
{
int a[] = {3, 7, 4, 8, 6, 2, 1, 5};
int up = 1;
BitonicSort ob = new BitonicSort();
ob.sort(a, a.length,up);
System.out.println(""\nSorted array"");
printArray(a);
}
}",
19,Pancake Sorting,"Following are the detailed steps. Let given array be arr   and size of array be n.    Start from current size equal to n and reduce current size by one while it s greater than 1. Let the current size be curr size.    Do following for every curr size       Find index of the maximum element in arr 0 to curr szie 1 . Let the index be  mi        Call flip arr, mi        Call flip arr, curr size   1 ","// Java program to
// sort array using
// pancake sort
import http://java.io/.;
class PancakeSort {
/ Reverses arr[0..i] /
static void flip(int arr[], int i)
{
int temp, start = 0;
while (start < i)
{
temp = arr[start];
arr[start] = arr[i];
arr[i] = temp;
start++;
i--;
}
}
// Returns index of the
// maximum element in
// arr[0..n-1]
static int findMax(int arr[], int n)
{
int mi, i;
for (mi = 0, i = 0; i < n; ++i)
if (arr[i] > arr[mi])
mi = i;
return mi;
}
// The main function that
// sorts given array using
// flip operations
static int pancakeSort(int arr[], int n)
{
// Start from the complete
// array and one by one
// reduce current size by one
for (int curr_size = n; curr_size > 1;
--curr_size)
{
// Find index of the
// maximum element in
// arr[0..curr_size-1]
int mi = findMax(arr, curr_size);
// Move the maximum element
// to end of current array
// if it's not already at
// the end
if (mi != curr_size-1)
{
// To move at the end,
// first move maximum
// number to beginning
flip(arr, mi);
// Now move the maximum
// number to end by
// reversing current array
flip(arr, curr_size-1);
}
}
return 0;
}
/ Utility function to print array arr[] /
static void printArray(int arr[], int arr_size)
{
for (int i = 0; i < arr_size; i++)
System.out.print(arr[i] + "" "");
System.out.println("""");
}
/ Driver function to check for above functions*/
public static void main (String[] args)
{
int arr[] = {23, 10, 20, 11, 12, 6, 7};
int n = arr.length;
pancakeSort(arr, n);
System.out.println(""Sorted Array: "");
printArray(arr, n);
}
}
/* This code is contributed by Devesh Agrawal*/",
20,BogoSort,"BogoSort also known as permutation sort, stupid sort, slow sort, shotgun sort or monkey sort is a particularly ineffective algorithm one person can ever imagine. It is based on generate and test paradigm. The algorithm successively generates permutations of its input until it finds one that is sorted. Wiki  For example, if bogosort is used to sort a deck of cards, it would consist of checking if the deck were in order, and if it were not, one would throw the deck into the air, pick the cards up at random, and repeat the process until the deck is sorted.","// Java Program to implement BogoSort
public class BogoSort {
// Sorts array a[0..n-1] using Bogo sort
void bogoSort(int[] a)
{
// if array is not sorted then shuffle the
// array again
while (isSorted(a) == false)
shuffle(a);
}
// To generate permutation of the array
void shuffle(int[] a)
{
// Math.random() returns a double positive
// value, greater than or equal to 0.0 and
// less than 1.0.
for (int i = 1; i < a.length; i++)
swap(a, i, (int)(Math.random() * i));
}
// Swapping 2 elements
void swap(int[] a, int i, int j)
{
int temp = a[i];
a[i] = a[j];
a[j] = temp;
}
// To check if array is sorted or not
boolean isSorted(int[] a)
{
for (int i = 1; i < a.length; i++)
if (a[i] < a[i - 1])
return false;
return true;
}
// Prints the array
void printArray(int[] arr)
{
for (int i = 0; i < arr.length; i++)
System.out.print(arr[i] + "" "");
System.out.println();
}
public static void main(String[] args)
{
// Enter array to be sorted here
int[] a = { 3, 2, 5, 1, 0, 4 };
BogoSort ob = new BogoSort();
ob.bogoSort(a);
System.out.print(""Sorted array: "");
ob.printArray(a);
}
}",
21,Gnome Sort,"Gnome Sort also called Stupid sort is based on the concept of a Garden Gnome sorting his flower pots. A garden gnome sorts the flower pots by the following method      He looks at the flower pot next to him and the previous one  if they are in the right order he steps one pot forward, otherwise he swaps them and steps one pot backwards.   If there is no previous pot  he is at the starting of the pot line , he steps forwards  if there is no pot next to him  he is at the end of the pot line , he is done.","// Java Program to implement Gnome Sort
import java.util.Arrays;
public class GFG {
static void gnomeSort(int arr[], int n)
{
int index = 0;
while (index < n) {
if (index == 0)
index++;
if (arr[index] >= arr[index - 1])
index++;
else {
int temp = 0;
temp = arr[index];
arr[index] = arr[index - 1];
arr[index - 1] = temp;
index--;
}
}
return;
}
// Driver program to test above functions.
public static void main(String[] args)
{
int arr[] = { 34, 2, 10, -9 };
gnomeSort(arr, arr.length);
System.out.print(""Sorted sequence after applying Gnome sort: "");
System.out.println(Arrays.toString(arr));
}
}
// Code Contributed by Mohit Gupta_OMG",
22,Sleep Sort,"In this algorithm we create different threads for each of the elements in the input array and then each thread sleeps for an amount of time which is proportional to the value of corresponding array element. Hence, the thread having the least amount of sleeping time wakes up first and the number gets printed and then the second least element and so on. The largest element wakes up after a long time and then the element gets printed at the last. Thus the output is a sorted one. All this multithreading process happens in background and at the core of the OS. We do not get to know anything about what s happening in the background, hence this is a  mysterious  sorting algorithm.","import java.util.ArrayList;
class SleepSort {
public static void main(String[] args) {
ArrayList<Integer> arr = new ArrayList<>();
arr.add(34); // Add elements to the ArrayList
arr.add(23);
arr.add(122);
arr.add(9);
sleepSort(arr); // Call the sleepSort function to sort the ArrayList
}
public static void sleepSort(ArrayList<Integer> arr) {
ArrayList<Thread> threads = new ArrayList<>(); // Create an ArrayList to hold threads
for (int num : arr) {
Thread thread = new Thread(() -> {
try {
Thread.sleep(num); // Sleep for 'num' milliseconds
System.out.print(num + "" ""); // Print the number after sleeping
} catch (InterruptedException e) {
e.printStackTrace();
}
});
threads.add(thread); // Add the thread to the ArrayList
thread.start(); // Start the thread
}
for (Thread thread : threads) {
try {
thread.join(); // Wait for each thread to finish
} catch (InterruptedException e) {
e.printStackTrace();
}
}
}
}",
23,Stooge Sort,"Stooge Sort is a recursive sorting algorithm. It is not much efficient but interesting sorting algorithm. It generally divides the array into two overlapping parts  2 3 each . After that it performs sorting in first 2 3 part and then it performs sorting in last 2 3 part. And then, sorting is done on first 2 3 part to ensure that the array is sorted.","// Java program to implement stooge sort
import http://java.io/.*;
public class stooge {
// Function to implement stooge sort
static void stoogesort(int arr[], int l, int h)
{
if (l >= h)
return;
// If first element is smaller
// than last, swap them
if (arr[l] > arr[h]) {
int t = arr[l];
arr[l] = arr[h];
arr[h] = t;
}
// If there are more than 2 elements in
// the array
if (h - l + 1 > 2) {
int t = (h - l + 1) / 3;
// Recursively sort first 2/3 elements
stoogesort(arr, l, h - t);
// Recursively sort last 2/3 elements
stoogesort(arr, l + t, h);
// Recursively sort first 2/3 elements
// again to confirm
stoogesort(arr, l, h - t);
}
}
// Driver Code
public static void main(String args[])
{
int arr[] = { 2, 4, 5, 3, 1 };
int n = arr.length;
stoogesort(arr, 0, n - 1);
for (int i = 0; i < n; i++)
System.out.print(arr[i] + "" "");
}
}
// Code Contributed by Mohit Gupta_OMG <(0_o)>",
24,Tag Sort,"When we are operating on large array of objects, it might be too costly to swap these large object. After all its about the disk swaps and we want to minimize it!   Tag Sort allows sorting an integer array after tagging it with original object.   In turn, we only swap the tag array integers instead of large array of objects.   The actual elements are not being changed during the sort process. The positions in the tag array are being changed so they will hold the correct ordering of the elements when they are sorted.","// Java Program to illustrate Tag Sort. This code
// uses Bubble Sort to modify tag array according
// to salaries. We can use other optimized sorting
// techniques also.
class Person
{
private int id;
private float salary;
private Object someBigObject = new Object();
public Person(int id, float salary)
{
http://this.id/ = id;
this.salary = salary;
}
public float getSalary()
{
return salary;
}
@Override
public String toString()
{
return ""Person{"" +
""id="" + id +
"", salary="" + salary +
"", someBigObject="" + someBigObject +
'}';
}
}
public class Main
{
public static void main(String[] args)
{
// Creating objects and their original
// order (in tag array)
int n = 5;
Person persons[] = new Person[n];
persons[0] = new Person(0, 233.5f);
persons[1] = new Person(1, 23f);
persons[2] = new Person(2, 13.98f);
persons[3] = new Person(3, 143.2f);
persons[4] = new Person(4, 3f);
int tag[] = new int[n];
for (int i = 0; i < n; i++)
tag[i] = i;
// Every Person object is tagged to
// an element in the tag array.
System.out.println(""Given Person and Tag "");
for (int i = 0; i < n; i++)
System.out.println(persons[i] +
"" : Tag: "" + tag[i]);
// Modifying tag array so that we can access
// persons in sorted order.
tagSort(persons, tag);
System.out.println(""New Tag Array after ""+
""getting sorted as per Person[] "");
for (int i=0; i<n; i++)
System.out.println(tag[i]);
// Accessing persons in sorted (by salary)
// way using modified tag array.
for (int i = 0; i < n; i++)
System.out.println(persons[tag[i]]);
}
// Modifying tag array so that we can access
// persons in sorted order of salary.
public static void tagSort(Person persons[],
int tag[])
{
int n = persons.length;
for (int i=0; i<n; i++)
{
for (int j=i+1; j<n; j++)
{
if (persons[tag[i]].getSalary() >
persons[tag[j]].getSalary())
{
// Note we are not sorting the
// actual Persons array, but only
// the tag array
int temp = tag[i];
tag[i] = tag[j];
tag[j] = temp;
}
}
}
}
}",
25,Tree Sort,Tree sort is a sorting algorithm that is based on Binary Search Tree data structure. It first creates a binary search tree from the elements of the input list or array and then performs an in order traversal on the created binary search tree to get the elements in sorted order.,"// Java program to
// implement Tree Sort
class GFG
{
// Class containing left and
// right child of current
// node and key value
class Node
{
int key;
Node left, right;
public Node(int item)
{
key = item;
left = right = null;
}
}
// Root of BST
Node root;
// Constructor
GFG()
{
root = null;
}
// This method mainly
// calls insertRec()
void insert(int key)
{
root = insertRec(root, key);
}
/* A recursive function to
insert a new key in BST /
Node insertRec(Node root, int key)
{
/ If the tree is empty,
return a new node /
if (root == null)
{
root = new Node(key);
return root;
}
/ Otherwise, recur
down the tree /
if (key < root.key)
root.left = insertRec(root.left, key);
else if (key > root.key)
root.right = insertRec(root.right, key);
/ return the root */
return root;
}
// A function to do
// inorder traversal of BST
void inorderRec(Node root)
{
if (root != null)
{
inorderRec(root.left);
System.out.print(root.key + "" "");
inorderRec(root.right);
}
}
void treeins(int arr[])
{
for(int i = 0; i < arr.length; i++)
{
insert(arr[i]);
}
}
// Driver Code
public static void main(String[] args)
{
GFG tree = new GFG();
int arr[] = {5, 4, 7, 2, 11};
tree.treeins(arr);
tree.inorderRec(tree.root);
}
}
// This code is contributed
// by Vibin M",
26,Dijkstra,"The idea is to generate a SPT  shortest path tree  with a given source as a root. Maintain an Adjacency Matrix with two sets, one set contains vertices included in the shortest path tree, other set includes vertices not yet included in the shortest path tree.  At every step of the algorithm, find a vertex that is in the other set  set not yet included  and has a minimum distance from the source.","// A Java program for Dijkstra's single source shortest path
// algorithm. The program is for adjacency matrix
// representation of the graph
import http://java.io/.;
import java.lang.;
import java.util.;
class ShortestPath {
// A utility function to find the vertex with minimum
// distance value, from the set of vertices not yet
// included in shortest path tree
static final int V = 9;
int minDistance(int dist[], Boolean sptSet[])
{
// Initialize min value
int min = Integer.MAX_VALUE, min_index = -1;
for (int v = 0; v < V; v++)
if (sptSet[v] == false && dist[v] <= min) {
min = dist[v];
min_index = v;
}
return min_index;
}
// A utility function to print the constructed distance
// array
void printSolution(int dist[])
{
System.out.println(
""Vertex \t\t Distance from Source"");
for (int i = 0; i < V; i++)
System.out.println(i + "" \t\t "" + dist[i]);
}
// Function that implements Dijkstra's single source
// shortest path algorithm for a graph represented using
// adjacency matrix representation
void dijkstra(int graph[][], int src)
{
int dist[] = new int[V]; // The output array.
// dist[i] will hold
// the shortest distance from src to i
// sptSet[i] will true if vertex i is included in
// shortest path tree or shortest distance from src
// to i is finalized
Boolean sptSet[] = new Boolean[V];
// Initialize all distances as INFINITE and stpSet[]
// as false
for (int i = 0; i < V; i++) {
dist[i] = Integer.MAX_VALUE;
sptSet[i] = false;
}
// Distance of source vertex from itself is always 0
dist[src] = 0;
// Find shortest path for all vertices
for (int count = 0; count < V - 1; count++) {
// Pick the minimum distance vertex from the set
// of vertices not yet processed. u is always
// equal to src in first iteration.
int u = minDistance(dist, sptSet);
// Mark the picked vertex as processed
sptSet[u] = true;
// Update dist value of the adjacent vertices of
// the picked vertex.
for (int v = 0; v < V; v++)
// Update dist[v] only if is not in sptSet,
// there is an edge from u to v, and total
// weight of path from src to v through u is
// smaller than current value of dist[v]
if (!sptSet[v] && graph[u][v] != 0
&& dist[u] != Integer.MAX_VALUE
&& dist[u] + graph[u][v] < dist[v])
dist[v] = dist[u] + graph[u][v];
}
// print the constructed distance array
printSolution(dist);
}
// Driver's code
public static void main(String[] args)
{
/ Let us create the example graph discussed above
*/
int graph[][]
= new int[][] { { 0, 4, 0, 0, 0, 0, 0, 8, 0 },
{ 4, 0, 8, 0, 0, 0, 0, 11, 0 },
{ 0, 8, 0, 7, 0, 4, 0, 0, 2 },
{ 0, 0, 7, 0, 9, 14, 0, 0, 0 },
{ 0, 0, 0, 9, 0, 10, 0, 0, 0 },
{ 0, 0, 4, 14, 10, 0, 2, 0, 0 },
{ 0, 0, 0, 0, 0, 2, 0, 1, 6 },
{ 8, 11, 0, 0, 0, 0, 1, 0, 7 },
{ 0, 0, 2, 0, 0, 0, 6, 7, 0 } };
ShortestPath t = new ShortestPath();
// Function call
t.dijkstra(graph, 0);
}
}
// This code is contributed by Aakash Hasija",
27,Bellman-Ford,"Imagine you have a map with different cities connected by roads, each road having a certain distance. The Bellman Ford algorithm is like a guide that helps you find the shortest path from one city to all other cities, even if some roads have negative lengths. It s like a GPS for computers, useful for figuring out the quickest way to get from one point to another in a network. In this article, we ll take a closer look at how this algorithm works and why it s so handy in solving everyday problems.","// A Java program for Bellman-Ford's single source shortest
// path algorithm.
import http://java.io/.;
import java.lang.;
import java.util.*;
// A class to represent a connected, directed and weighted
// graph
class Graph {
// A class to represent a weighted edge in graph
class Edge {
int src, dest, weight;
Edge() { src = dest = weight = 0; }
};
int V, E;
Edge edge[];
// Creates a graph with V vertices and E edges
Graph(int v, int e)
{
V = v;
E = e;
edge = new Edge[e];
for (int i = 0; i < e; ++i)
edge[i] = new Edge();
}
// The main function that finds shortest distances from
// src to all other vertices using Bellman-Ford
// algorithm. The function also detects negative weight
// cycle
void BellmanFord(Graph graph, int src)
{
int V = graph.V, E = graph.E;
int dist[] = new int[V];
// Step 1: Initialize distances from src to all
// other vertices as INFINITE
for (int i = 0; i < V; ++i)
dist[i] = Integer.MAX_VALUE;
dist[src] = 0;
// Step 2: Relax all edges |V| - 1 times. A simple
// shortest path from src to any other vertex can
// have at-most |V| - 1 edges
for (int i = 1; i < V; ++i) {
for (int j = 0; j < E; ++j) {
int u = graph.edge[j].src;
int v = graph.edge[j].dest;
int weight = graph.edge[j].weight;
if (dist[u] != Integer.MAX_VALUE
&& dist[u] + weight < dist[v])
dist[v] = dist[u] + weight;
}
}
// Step 3: check for negative-weight cycles. The
// above step guarantees shortest distances if graph
// doesn't contain negative weight cycle. If we get
// a shorter path, then there is a cycle.
for (int j = 0; j < E; ++j) {
int u = graph.edge[j].src;
int v = graph.edge[j].dest;
int weight = graph.edge[j].weight;
if (dist[u] != Integer.MAX_VALUE
&& dist[u] + weight < dist[v]) {
System.out.println(
""Graph contains negative weight cycle"");
return;
}
}
printArr(dist, V);
}
// A utility function used to print the solution
void printArr(int dist[], int V)
{
System.out.println(""Vertex Distance from Source"");
for (int i = 0; i < V; ++i)
System.out.println(i + ""\t\t"" + dist[i]);
}
// Driver's code
public static void main(String[] args)
{
int V = 5; // Number of vertices in graph
int E = 8; // Number of edges in graph
Graph graph = new Graph(V, E);
// add edge 0-1 (or A-B in above figure)
graph.edge[0].src = 0;
graph.edge[0].dest = 1;
graph.edge[0].weight = -1;
// add edge 0-2 (or A-C in above figure)
graph.edge[1].src = 0;
graph.edge[1].dest = 2;
graph.edge[1].weight = 4;
// add edge 1-2 (or B-C in above figure)
graph.edge[2].src = 1;
graph.edge[2].dest = 2;
graph.edge[2].weight = 3;
// add edge 1-3 (or B-D in above figure)
graph.edge[3].src = 1;
graph.edge[3].dest = 3;
graph.edge[3].weight = 2;
// add edge 1-4 (or B-E in above figure)
graph.edge[4].src = 1;
graph.edge[4].dest = 4;
graph.edge[4].weight = 2;
// add edge 3-2 (or D-C in above figure)
graph.edge[5].src = 3;
graph.edge[5].dest = 2;
graph.edge[5].weight = 5;
// add edge 3-1 (or D-B in above figure)
graph.edge[6].src = 3;
graph.edge[6].dest = 1;
graph.edge[6].weight = 1;
// add edge 4-3 (or E-D in above figure)
graph.edge[7].src = 4;
graph.edge[7].dest = 3;
graph.edge[7].weight = -3;
// Function call
graph.BellmanFord(graph, 0);
}
}
// Contributed by Aakash Hasija
",
28,Floyd Warshall,Suppose we have a graph G     with V vertices from 1 to N. Now we have to evaluate a shortestPathMatrix     where shortestPathMatrix i  j  represents the shortest path between vertices i and j. Obviously the shortest path between i to j will have some k number of intermediate nodes. The idea behind floyd warshall algorithm is to treat each and every vertex from 1 to N as an intermediate node one by one.,"// Java program for Floyd Warshall All Pairs Shortest
// Path algorithm.
import http://java.io/.;
import java.lang.;
import java.util.;
class AllPairShortestPath {
final static int INF = 99999, V = 4;
void floydWarshall(int dist[][])
{
int i, j, k;
/ Add all vertices one by one
to the set of intermediate
vertices.
---> Before start of an iteration,
we have shortest
distances between all pairs
of vertices such that
the shortest distances consider
only the vertices in
set {0, 1, 2, .. k-1} as
intermediate vertices.
----> After the end of an iteration,
vertex no. k is added
to the set of intermediate
vertices and the set
becomes {0, 1, 2, .. k} /
for (k = 0; k < V; k++) {
// Pick all vertices as source one by one
for (i = 0; i < V; i++) {
// Pick all vertices as destination for the
// above picked source
for (j = 0; j < V; j++) {
// If vertex k is on the shortest path
// from i to j, then update the value of
// dist[i][j]
if (dist[i][k] + dist[k][j]
< dist[i][j])
dist[i][j]
= dist[i][k] + dist[k][j];
}
}
}
// Print the shortest distance matrix
printSolution(dist);
}
void printSolution(int dist[][])
{
System.out.println(
""The following matrix shows the shortest ""
+ ""distances between every pair of vertices"");
for (int i = 0; i < V; ++i) {
for (int j = 0; j < V; ++j) {
if (dist[i][j] == INF)
System.out.print(""INF "");
else
System.out.print(dist[i][j] + "" "");
}
System.out.println();
}
}
// Driver's code
public static void main(String[] args)
{
/ Let us create the following weighted graph
10
(0)------->(3)
| /|\
5 | |
| | 1
\|/ |
(1)------->(2)
3 */
int graph[][] = { { 0, 5, INF, 10 },
{ INF, 0, 3, INF },
{ INF, INF, 0, 1 },
{ INF, INF, INF, 0 } };
AllPairShortestPath a = new AllPairShortestPath();
// Function call
a.floydWarshall(graph);
}
}
// Contributed by Aakash Hasija",
29,Johnson,"Algorithm   1. Let the given graph be G. Add a new vertex s to the graph, add edges from the new vertex to all vertices of G. Let the modified graph be G . Run the Bellman Ford algorithm on G  with s as the source. Let the distances calculated by Bellman Ford be h 0 , h 1 , .. h V 1 . If we find a negative weight cycle, then return. Note that the negative weight cycle cannot be created by new vertex s as there is no edge to s. All edges are from s. Reweight the edges of the original graph. For each edge  u, v , assign the new weight as  original weight   h u    h v  . Remove the added vertex s and run Dijkstra s algorithm for every vertex.","import java.util.;
public class GFG {
// Number of vertices in the graph
static final int V = 4;
static final int INF = 99999;
// A utility function to find the vertex with minimum
// distance value, from the set of vertices not yet
// included in shortest path tree
static int minDistance(int[] dist, boolean[] sptSet)
{
// Initialize min value
int min = INF, min_index = -1;
for (int v = 0; v < V; v++)
if (!sptSet[v] && dist[v] <= min) {
min = dist[v];
min_index = v;
}
return min_index;
}
// A utility function to print the constructed distance
// array
static void printSolution(int[][] dist)
{
System.out.println(
""Following matrix shows the shortest distances ""
+ ""between every pair of vertices:"");
for (int i = 0; i < V; i++) {
for (int j = 0; j < V; j++) {
if (dist[i][j] == INF)
System.out.printf(""%7s"", ""INF"");
else
System.out.printf(""%7d"", dist[i][j]);
}
System.out.println();
}
}
// Solves the all-pairs shortest path problem using
// Floyd Warshall algorithm
static void floydWarshall(int[][] graph)
{
int[][] dist = new int[V][V];
int i, j, k;
/ Initialize the solution matrix same as input
graph matrix. Or we can say the initial values of
shortest distances are based on shortest paths
considering no intermediate vertex. /
for (i = 0; i < V; i++)
for (j = 0; j < V; j++)
dist[i][j] = graph[i][j];
/ Add all vertices one by one to the set of
intermediate vertices.
---> Before start of a iteration, we have shortest
distances between all pairs of vertices such that
the shortest distances consider only the vertices
in set {0, 1, 2, .. k-1} as intermediate vertices.
----> After the end of a iteration, vertex no. k
is added to the set of intermediate vertices and
the set becomes {0, 1, 2, .. k} /
for (k = 0; k < V; k++) {
// Pick all vertices as source one by one
for (i = 0; i < V; i++) {
// Pick all vertices as destination for the
// above picked source
for (j = 0; j < V; j++) {
// If vertex k is on the shortest path
// from i to j, then update the value of
// dist[i][j]
if (dist[i][k] + dist[k][j]
< dist[i][j])
dist[i][j]
= dist[i][k] + dist[k][j];
}
}
}
// Print the shortest distance matrix
printSolution(dist);
}
// driver program to test above function
public static void main(String[] args)
{
/ Let us create the following weighted graph
10
(0)------->(3)
| /|\
5 | |
| | 1
\|/ |
(1)------->(2)
3 */
int[][] graph = { { 0, 5, INF, 10 },
{ INF, 0, 3, INF },
{ INF, INF, 0, 1 },
{ INF, INF, INF, 0 } };
// Print the solution
floydWarshall(graph);
}
}",
30,Shortest Path in Directed Acyclic Graph,"Following is complete algorithm for finding shortest distances.  1. Initialize dist      INF, INF,  .  and dist s    0 where s is the source vertex. Create a topological order of all vertices. Do following for every vertex u in topological order.    ..Do following for every adjacent vertex v of u       if  dist v    dist u    weight u, v            dist v    dist u    weight u, v ","// Java program to find single source shortest paths in Directed Acyclic Graphs
import http://java.io/.;
import java.util.;
class ShortestPath
{
static final int INF=Integer.MAX_VALUE;
class AdjListNode
{
private int v;
private int weight;
AdjListNode(int _v, int _w) { v = _v; weight = _w; }
int getV() { return v; }
int getWeight() { return weight; }
}
// Class to represent graph as an adjacency list of
// nodes of type AdjListNode
class Graph
{
private int V;
private LinkedList<AdjListNode>adj[];
Graph(int v)
{
V=v;
adj = new LinkedList[V];
for (int i=0; i<v; ++i)
adj[i] = new LinkedList<AdjListNode>();
}
void addEdge(int u, int v, int weight)
{
AdjListNode node = new AdjListNode(v,weight);
adj[u].add(node);// Add v to u's list
}
// A recursive function used by shortestPath.
// See below link for details
void topologicalSortUtil(int v, Boolean visited[], Stack stack)
{
// Mark the current node as visited.
visited[v] = true;
Integer i;
// Recur for all the vertices adjacent to this vertex
Iterator<AdjListNode> it = adj[v].iterator();
while (it.hasNext())
{
AdjListNode node =it.next();
if (!visited[node.getV()])
topologicalSortUtil(node.getV(), visited, stack);
}
// Push current vertex to stack which stores result
stack.push(new Integer(v));
}
// The function to find shortest paths from given vertex. It
// uses recursive topologicalSortUtil() to get topological
// sorting of given graph.
void shortestPath(int s)
{
Stack stack = new Stack();
int dist[] = new int[V];
// Mark all the vertices as not visited
Boolean visited[] = new Boolean[V];
for (int i = 0; i < V; i++)
visited[i] = false;
// Call the recursive helper function to store Topological
// Sort starting from all vertices one by one
for (int i = 0; i < V; i++)
if (visited[i] == false)
topologicalSortUtil(i, visited, stack);
// Initialize distances to all vertices as infinite and
// distance to source as 0
for (int i = 0; i < V; i++)
dist[i] = INF;
dist[s] = 0;
// Process vertices in topological order
while (stack.empty() == false)
{
// Get the next vertex from topological order
int u = (int)stack.pop();
// Update distances of all adjacent vertices
Iterator<AdjListNode> it;
if (dist[u] != INF)
{
it = adj[u].iterator();
while (it.hasNext())
{
AdjListNode i= it.next();
if (dist[i.getV()] > dist[u] + i.getWeight())
dist[i.getV()] = dist[u] + i.getWeight();
}
}
}
// Print the calculated shortest distances
for (int i = 0; i < V; i++)
{
if (dist[i] == INF)
System.out.print( ""INF "");
else
System.out.print( dist[i] + "" "");
}
}
}
// Method to create a new graph instance through an object
// of ShortestPath class.
Graph newGraph(int number)
{
return new Graph(number);
}
public static void main(String args[])
{
// Create a graph given in the above diagram. Here vertex
// numbers are 0, 1, 2, 3, 4, 5 with following mappings:
// 0=r, 1=s, 2=t, 3=x, 4=y, 5=z
ShortestPath t = new ShortestPath();
Graph g = t.newGraph(6);
g.addEdge(0, 1, 5);
g.addEdge(0, 2, 3);
g.addEdge(1, 3, 6);
g.addEdge(1, 2, 2);
g.addEdge(2, 4, 4);
g.addEdge(2, 5, 2);
g.addEdge(2, 3, 7);
g.addEdge(3, 4, -1);
g.addEdge(4, 5, -2);
int s = 1;
System.out.println(""Following are shortest distances ""+
""from source "" + s );
g.shortestPath(s);
}
}
//This code is contributed by Aakash Hasija",
31,Dial,"Below is the complete algorithm  1. Maintains some buckets, numbered 0, 1, 2, ,wV. 2. Bucket k contains all temporarily labeled nodes with a distance equal to k. 3. Nodes in each bucket are represented by a list of vertices. 4. Buckets 0, 1, 2,..wV are checked sequentially until the first non empty bucket is found. Each node contained in the first non empty bucket has the minimum distance label by definition. 5. One by one, these nodes with minimum distance labels are permanently labeled and deleted from the bucket during the scanning process. 6. Thus operations involving vertex include        Checking if a bucket is empty       Adding a vertex to a bucket       Deleting a vertex from a bucket.  7. The position of a temporarily labeled vertex in the buckets is updated accordingly when the distance label of a vertex changes. 8. The process is repeated until all vertices are permanently labeled  or the distances of all vertices are finalized .","import java.util.;
public class Graph {
static final int INF = Integer.MAX_VALUE;
private int V; // No. of vertices
// In a weighted graph, we need to store vertex
// and weight pair for every edge
private ArrayList<ArrayList<Tuple> > adj;
public Graph(int v) // Constructor
{
this.V = v;
this.adj = new ArrayList<ArrayList<Tuple> >();
for (int i = 0; i < v; i++)
this.adj.add(new ArrayList<Tuple>());
}
// function to Add an edge to graph
// Adds edge between u and v of weight w
public void AddEdge(int u, int v, int w)
{
adj.get(u).add(new Tuple(v, w));
adj.get(v).add(new Tuple(u, w));
}
// Prints shortest paths from src to all other vertices.
// W is the maximum weight of an edge
public void shortestPath(int src, int W)
{
/ With each distance, iterator to that vertex in
its bucket is stored so that vertex can be
deleted in O(1) at time of updation. So
dist[i].first = distance of ith vertex from src
vertex dits[i].second = iterator to vertex i in
bucket number */
int[] dist = new int[V];
// Initialize all distances as infinite (INF)
Arrays.fill(dist, INF);
// Create buckets B[].
// B[i] keep vertex of distance label i
ArrayList<Integer>[] B = new ArrayList[W * V + 1];
for (int i = 0; i < W * V + 1; i++)
B[i] = new ArrayList<Integer>();
B[0].add(src);
dist[src] = 0;
int idx = 0;
while (true) {
// Go sequentially through buckets till one
// non-empty bucket is found
while (B[idx].size() == 0 && idx < W * V)
idx++;
// If all buckets are empty, we are done.
if (idx == W * V)
break;
// Take top vertex from bucket and pop it
int u = B[idx].get(0);
B[idx].remove(0);
// Process all adjacents of extracted vertex 'u'
// and update their distances if required.
for (Tuple i : adj.get(u)) {
int v = i.v;
int weight = i.w;
int du = dist[u];
int dv = dist[v];
// If there is shorted path to v through u.
if (dv > du + weight) {
// updating the distance
dist[v] = du + weight;
dv = dist[v];
// pushing vertex v into updated
// distance's bucket
B[dv].add(0, v);
}
}
}
// Print shortest distances stored in dist[]
System.out.println(""Vertex Distance from Source"");
for (int i = 0; i < V; ++i)
System.out.println(i + ""\t\t"" + dist[i]);
}
static class Tuple {
int v, w;
Tuple(int v, int w)
{
this.v = v;
this.w = w;
}
}
public static void main(String[] args)
{
// create the graph given in above figure
int V = 9;
Graph g = new Graph(V);
// making above shown graph
g.AddEdge(0, 1, 4);
g.AddEdge(0, 7, 8);
g.AddEdge(1, 2, 8);
g.AddEdge(1, 7, 11);
g.AddEdge(2, 3, 7);
g.AddEdge(2, 8, 2);
g.AddEdge(2, 5, 4);
g.AddEdge(3, 4, 9);
g.AddEdge(3, 5, 14);
g.AddEdge(4, 5, 10);
g.AddEdge(5, 6, 2);
g.AddEdge(6, 7, 1);
g.AddEdge(6, 8, 6);
g.AddEdge(7, 8, 7);
// maximum weighted edge - 14
g.shortestPath(0, 14);
}
}",
32,Multistage graph,"A Multistage graph is a directed, weighted graph in which the nodes can be divided into a set of stages such that all edges are from a stage to next stage only  In other words there is no edge between vertices of same stage and from a vertex of current stage to previous stage .","// Java program to find shortest distance
// in a multistage graph.
import http://java.io/.;
import java.util.;
class GFG {
static int N = 8;
static int INF = Integer.MAX_VALUE;
// Returns shortest distance from 0 to
// N-1.
public static int shortestDist(int[][] graph)
{
// dist[i] is going to store shortest
// distance from node i to node N-1.
int[] dist = new int[N];
dist[N - 1] = 0;
// Calculating shortest path for
// rest of the nodes
for (int i = N - 2; i >= 0; i--) {
// Initialize distance from i to
// destination (N-1)
dist[i] = INF;
// Check all nodes of next stages
// to find shortest distance from
// i to N-1.
for (int j = i; j < N; j++) {
// Reject if no edge exists
if (graph[i][j] == INF) {
continue;
}
// We apply recursive equation to
// distance to target through j.
// and compare with minimum distance
// so far.
dist[i] = Math.min(dist[i],
graph[i][j] + dist[j]);
}
}
return dist[0];
}
// Driver code
public static void main(String[] args)
{
// Graph stored in the form of an
// adjacency Matrix
int[][] graph = new int[][] {
{ INF, 1, 2, 5, INF, INF, INF, INF },
{ INF, INF, INF, INF, 4, 11, INF, INF },
{ INF, INF, INF, INF, 9, 5, 16, INF },
{ INF, INF, INF, INF, INF, INF, 2, INF },
{ INF, INF, INF, INF, INF, INF, INF, 18 },
{ INF, INF, INF, INF, INF, INF, INF, 13 },
{ INF, INF, INF, INF, INF, INF, INF, 2 }
};
System.out.println(shortestDist(graph));
}
}
// This code has been contributed by 29AjayKumar",
33,Shortest path in an unweighted graph,"Create a queue and add the starting vertex to it.  Create an array to keep track of the distances from the starting vertex to all other vertices. Initialize all distances to infinity except for the starting vertex, which should have a distance of 0.  While the queue is not empty, dequeue the next vertex.  For each neighbor of the dequeued vertex that has not been visited, set its distance to the distance of the dequeued vertex plus 1 and add it to the queue.  Repeat steps 3 4 until the queue is empty.  The distances array now contains the shortest path distances from the starting vertex to all other vertices.","// Java program to find shortest path in an undirected
// graph
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
public class pathUnweighted {
// Driver Program
public static void main(String args[])
{
// No of vertices
int v = 8;
// Adjacency list for storing which vertices are connected
ArrayList<ArrayList<Integer>> adj =
new ArrayList<ArrayList<Integer>>(v);
for (int i = 0; i < v; i++) {
adj.add(new ArrayList<Integer>());
}
// Creating graph given in the above diagram.
// add_edge function takes adjacency list, source
// and destination vertex as argument and forms
// an edge between them.
addEdge(adj, 0, 1);
addEdge(adj, 0, 3);
addEdge(adj, 1, 2);
addEdge(adj, 3, 4);
addEdge(adj, 3, 7);
addEdge(adj, 4, 5);
addEdge(adj, 4, 6);
addEdge(adj, 4, 7);
addEdge(adj, 5, 6);
addEdge(adj, 6, 7);
int source = 0, dest = 7;
printShortestDistance(adj, source, dest, v);
}
// function to form edge between two vertices
// source and dest
private static void addEdge(ArrayList<ArrayList<Integer>> adj, int i, int j)
{
adj.get(i).add(j);
adj.get(j).add(i);
}
// function to print the shortest distance and path
// between source vertex and destination vertex
private static void printShortestDistance(
ArrayList<ArrayList<Integer>> adj,
int s, int dest, int v)
{
// predecessor[i] array stores predecessor of
// i and distance array stores distance of i
// from s
int pred[] = new int[v];
int dist[] = new int[v];
if (BFS(adj, s, dest, v, pred, dist) == false) {
System.out.println(""Given source and destination"" +
""are not connected"");
return;
}
// LinkedList to store path
LinkedList<Integer> path = new LinkedList<Integer>();
int crawl = dest;
path.add(crawl);
while (pred[crawl] != -1) {
path.add(pred[crawl]);
crawl = pred[crawl];
}
// Print distance
System.out.println(""Shortest path length is: "" + dist[dest]);
// Print path
System.out.println(""Path is ::"");
for (int i = path.size() - 1; i >= 0; i--) {
System.out.print(path.get(i) + "" "");
}
}
// a modified version of BFS that stores predecessor
// of each vertex in array pred
// and its distance from source in array dist
private static boolean BFS(ArrayList<ArrayList<Integer>> adj, int src,
int dest, int v, int pred[], int dist[])
{
// a queue to maintain queue of vertices whose
// adjacency list is to be scanned as per normal
// BFS algorithm using LinkedList of Integer type
LinkedList<Integer> queue = new LinkedList<Integer>();
// boolean array visited[] which stores the
// information whether ith vertex is reached
// at least once in the Breadth first search
boolean visited[] = new boolean[v];
// initially all vertices are unvisited
// so v[i] for all i is false
// and as no path is yet constructed
// dist[i] for all i set to infinity
for (int i = 0; i < v; i++) {
visited[i] = false;
dist[i] = Integer.MAX_VALUE;
pred[i] = -1;
}
// now source is first to be visited and
// distance from source to itself should be 0
visited[src] = true;
dist[src] = 0;
queue.add(src);
// bfs Algorithm
while (!queue.isEmpty()) {
int u = queue.remove();
for (int i = 0; i < adj.get(u).size(); i++) {
if (visited[adj.get(u).get(i)] == false) {
visited[adj.get(u).get(i)] = true;
dist[adj.get(u).get(i)] = dist[u] + 1;
pred[adj.get(u).get(i)] = u;
queue.add(adj.get(u).get(i));
// stopping condition (when we find
// our destination)
if (adj.get(u).get(i) == dest)
return true;
}
}
}
return false;
}
}
// This code is contributed by Sahil Vaid",
34,Karps minimum mean (or average) weight cycle algorithm,"Step 2  Compute the shortest path to all other vertices on a path consisting of k edges 0    k    V where V is number of vertices. This is a simple dp problem which can be computed by the recursive solution dp k  v    min dp k  v , dp k 1  u    weight u,v  where v is the destination and the edge u,v  should belong to E Step 3  For each vertex calculate max dp n  v  dp k  v    n k  where 0  k  n 1 Step 4  The minimum of the values calculated above is the required answer.","// Java program to find minimum average
// weight of a cycle in connected and
// directed graph.
import http://java.io/.;
import java.util.;
class GFG
{
static int V = 4;
// a struct to represent edges
static class Edge
{
int from, weight;
Edge(int from, int weight)
{
this.from = from;
this.weight = weight;
}
}
// vector to store edges
//@SuppressWarnings(""unchecked"")
static Vector<Edge>[] edges = new Vector[V];
static
{
for (int i = 0; i < V; i++)
edges[i] = new Vector<>();
}
static void addedge(int u, int v, int w)
{
edges[v].add(new Edge(u, w));
}
// calculates the shortest path
static void shortestpath(int[][] dp)
{
// initializing all distances as -1
for (int i = 0; i <= V; i++)
for (int j = 0; j < V; j++)
dp[i][j] = -1;
// shortest distance from first vertex
// to in itself consisting of 0 edges
dp[0][0] = 0;
// filling up the dp table
for (int i = 1; i <= V; i++)
{
for (int j = 0; j < V; j++)
{
for (int k = 0; k < edges[j].size(); k++)
{
if (dp[i - 1][edges[j].elementAt(k).from] != -1)
{
int curr_wt = dp[i - 1][edges[j].elementAt(k).from] +
edges[j].elementAt(k).weight;
if (dp[i][j] == -1)
dp[i][j] = curr_wt;
else
dp[i][j] = Math.min(dp[i][j], curr_wt);
}
}
}
}
}
// Returns minimum value of average weight
// of a cycle in graph.
static double minAvgWeight()
{
int[][] dp = new int[V + 1][V];
shortestpath(dp);
// array to store the avg values
double[] avg = new double[V];
for (int i = 0; i < V; i++)
avg[i] = -1;
// Compute average values for all vertices using
// weights of shortest paths store in dp.
for (int i = 0; i < V; i++)
{
if (dp[V][i] != -1)
{
for (int j = 0; j < V; j++)
if (dp[j][i] != -1)
avg[i] = Math.max(avg[i],
((double) dp[V][i] -
dp[j][i]) / (V - j));
}
}
// Find minimum value in avg[]
double result = avg[0];
for (int i = 0; i < V; i++)
if (avg[i] != -1 && avg[i] < result)
result = avg[i];
return result;
}
// Driver Code
public static void main(String[] args)
{
addedge(0, 1, 1);
addedge(0, 2, 10);
addedge(1, 2, 3);
addedge(2, 3, 2);
addedge(3, 1, 0);
addedge(3, 0, 8);
System.out.printf(""%.5f"", minAvgWeight());
}
}
// This code is contributed by
// sanjeev2552",
35,0-1 BFS (Shortest Path in a Binary Weight Graph),"In normal BFS of a graph, all edges have equal weight but in 0 1 BFS some edges may have 0 weight and some may have 1 weight. In this, we will not use a bool array to mark visited nodes but at each step, we will check for the optimal distance condition. We use a double endedhttps   www.geeksforgeeks.org deque set 1 introduction applications to store the node. While performing BFS if an edge having weight   0 is found node is pushed at front of the double ended queue and if an edge having weight   1 is found, it is pushed to the back of the double ended queue.The approach is similar to Dijkstra that if the shortest distance to the node is relaxed by the previous node then only it will be pushed into the queue. The above idea works in all cases, when pop a vertex  like Dijkstra , it is the minimum weight vertex among the remaining vertices. If there is a 0 weight vertex adjacent to it, then this adjacent has the same distance. If there is a 1 weight adjacent, then this adjacent has maximum distance among all vertices in the dequeue  because all other vertices are either adjacent to the currently popped vertex or adjacent to previously popped vertices .","// Java Program to implement 0-1 BFS
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
public class ZeroOneBFS {
private static class Node {
int to; // the ending vertex
int weight; // the weight of the edge
public Node(int to, int wt) {
http://this.to/ = to;
this.weight = wt;
}
}
private static final int numVertex = 9;
private ArrayList<Node>[] edges = new ArrayList[numVertex];
public ZeroOneBFS() {
for (int i = 0; i < edges.length; i++) {
edges[i] = new ArrayList<Node>();
}
}
public void addEdge(int u, int v, int wt) {
edges[u].add(edges[u].size(), new Node(v, wt));
edges[v].add(edges[v].size(), new Node(u, wt));
}
public void zeroOneBFS(int src) {
// initialize distances from given source
int[] dist = new int[numVertex];
for (int i = 0; i < numVertex; i++) {
dist[i] = Integer.MAX_VALUE;
}
// double ended queue to do BFS
Deque<Integer> queue = new ArrayDeque<Integer>();
dist[src] = 0;
queue.addLast(src);
while (!queue.isEmpty()) {
int v = queue.removeFirst();
for (int i = 0; i < edges[v].size(); i++) {
// checking for optimal distance
if (dist[edges[v].get(i).to] >
dist[v] + edges[v].get(i).weight) {
// update the distance
dist[edges[v].get(i).to] =
dist[v] + edges[v].get(i).weight;
// put 0 weight edges to front and 1
// weight edges to back so that vertices
// are processed in increasing order of weight
if (edges[v].get(i).weight == 0) {
queue.addFirst(edges[v].get(i).to);
} else {
queue.addLast(edges[v].get(i).to);
}
}
}
}
for (int i = 0; i < dist.length; i++) {
System.out.print(dist[i] + "" "");
}
}
public static void main(String[] args) {
ZeroOneBFS graph = new ZeroOneBFS();
graph.addEdge(0, 1, 0);
graph.addEdge(0, 7, 1);
graph.addEdge(1, 7, 1);
graph.addEdge(1, 2, 1);
graph.addEdge(2, 3, 0);
graph.addEdge(2, 5, 0);
graph.addEdge(2, 8, 1);
graph.addEdge(3, 4, 1);
graph.addEdge(3, 5, 1);
graph.addEdge(4, 5, 1);
graph.addEdge(5, 6, 1);
graph.addEdge(6, 7, 1);
graph.addEdge(7, 8, 1);
int src = 0;//source node
graph.zeroOneBFS(src);
return;
}
}",
36,add, Adds two integers and returns their sum. 2.,"public int add(int a, int b) {
return a + b;
}",
37,even,"Returns true if the number is even, false otherwise.","public boolean isEven(int number) {
return number % 2 == 0;
}",
38,max,Returns the larger of two integers.,"public int max(int a, int b) {
return (a > b) ? a : b;
}",
39,factorial,Recursively calculates the factorial of a number.,"public int factorial(int n) {
if (n <= 1) return 1;
return n * factorial(n - 1);
}",
40,prime,Determines if a number is prime.,"public boolean isPrime(int n) {
if (n <= 1) return false;
for (int i = 2; i < n; i++) {
if (n % i == 0) return false;
}
return true;
}",
41,celsius,Converts Celsius to Fahrenheit,"public double celsiusToFahrenheit(double celsius) {
return (celsius * 9 / 5) + 32;
}",
42,area of circle,Computes the area of a circle given its radius.,"public double areaOfCircle(double radius) {
final double PI = 3.14159;
return PI * radius * radius;
}",
43,reverse string,Reverses a string and returns the new string.,"public String reverseString(String str) {
return new StringBuilder(str).reverse().toString();
}",
44,leap year,Checks if a year is a leap year.,"public boolean isLeapYear(int year) {
return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}",
45,gdc,Finds the greatest common divisor of two numbers using recursion.,"public int gcd(int a, int b) {
if (b == 0) return a;
return gcd(b, a % b);
}",
46,binary to decimal,converts binary to decimal.,"public int binaryToDecimal(int binary) {
int decimal = 0, base = 1;
while (binary > 0) {
int last_digit = binary % 10;
binary /= 10;
decimal += last_digit * base;
base *= 2;
}
return decimal;
}",
47,count digits,Counts the number of digits in an integer.,"public int countDigits(int number) {
int count = 0;
while (number != 0) {
number /= 10;
++count;
}
return count;
}",
48,fibonacci,Prints the first n numbers of the Fibonacci series.,"public void fibonacci(int n) {
int a = 0, b = 1, next;
for (int i = 0; i < n; i++) {
System.out.print(a + "" "");
next = a + b;
a = b;
b = next;
}
}",
49,palindrome,Checks if a number is a palindrome.,"public boolean isPalindrome(int number) {
int reversed = 0, original = number;
while (number != 0) {
reversed = reversed * 10 + number % 10;
number /= 10;
}
return original == reversed;
}",
50,power,Computes the power of a number  base raised to the exp .,"public int power(int base, int exp) {
int result = 1;
for (int i = 0; i < exp; i++) {
result *= base;
}
return result;
}",
